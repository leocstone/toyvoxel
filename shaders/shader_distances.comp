#version 450

const int CHUNK_WIDTH_METERS = 16;
const int CHUNK_HEIGHT_METERS = 32;
const int VOXELS_PER_METER = 16;
const int CHUNK_WIDTH_VOXELS = CHUNK_WIDTH_METERS * VOXELS_PER_METER;
const int CHUNK_HEIGHT_VOXELS = CHUNK_HEIGHT_METERS * VOXELS_PER_METER;

/*
struct VoxelChunk {
    int voxels[CHUNK_WIDTH_VOXELS * CHUNK_WIDTH_VOXELS * CHUNK_HEIGHT_VOXELS];
};
*/

layout(std430, binding = 0, row_major) buffer VoxelChunkIn {
    int voxels[CHUNK_WIDTH_VOXELS][CHUNK_WIDTH_VOXELS][CHUNK_HEIGHT_VOXELS];
};

int flatIndex(ivec3 coord) {
    return coord.x + coord.y * CHUNK_WIDTH_VOXELS + coord.z * CHUNK_WIDTH_VOXELS * CHUNK_WIDTH_VOXELS;
}

int getVoxel(ivec3 coord) {
    if ((coord.x < 0) ||
        (coord.x >= CHUNK_WIDTH_VOXELS) ||
        (coord.y < 0) ||
        (coord.y >= CHUNK_WIDTH_VOXELS) ||
        (coord.z < 0) ||
        (coord.z >= CHUNK_HEIGHT_VOXELS)) {
        return 0;
    }
    return voxels[coord.x][coord.y][coord.z];
}

void setVoxel(ivec3 coord, int v) {
    if ((coord.x < 0) ||
        (coord.x >= CHUNK_WIDTH_VOXELS) ||
        (coord.y < 0) ||
        (coord.y >= CHUNK_WIDTH_VOXELS) ||
        (coord.z < 0) ||
        (coord.z >= CHUNK_HEIGHT_VOXELS)) {
        return;
    }
    voxels[coord.x][coord.y][coord.z] = v;
}

const int max_search_radius = 2;
int findClosestVoxel(ivec3 checked) {
    /*
    if (checked.x < 0 || checked.y < 0 || checked.z < 0 ||
        checked.x >= CHUNK_WIDTH_VOXELS || checked.y >= CHUNK_WIDTH_VOXELS || checked.z >= CHUNK_HEIGHT_VOXELS)
        return 0;
    */
    for (int radius = 1; radius <= max_search_radius; radius++) {
        /* Currently checked voxel */
        ivec3 curVoxel = checked;
        //int minDistanceFound = max_search_radius; // Minimum distance value found in a voxel at this radius
        /* +X Plane */
        curVoxel.x = checked.x + radius;
        if (curVoxel.x < CHUNK_WIDTH_VOXELS) {
            for (curVoxel.y = max(0, checked.y - radius); (curVoxel.y <= (checked.y + radius)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z <= (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* -X Plane */
        curVoxel.x = checked.x - radius;
        if (curVoxel.x > 0) {
            for (curVoxel.y = max(0, checked.y - radius); (curVoxel.y <= (checked.y + radius)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z <= (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* +Y Plane */
        curVoxel.y = checked.y + radius;
        if (curVoxel.y < CHUNK_WIDTH_VOXELS) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z < (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* -Y Plane */
        curVoxel.y = checked.y - radius;
        if (curVoxel.y > 0) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z < (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* +Z Plane */
        curVoxel.z = checked.z + radius;
        if (curVoxel.z < CHUNK_HEIGHT_VOXELS) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.y = max(0, checked.y - radius + 1); (curVoxel.y < (checked.y + radius - 1)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* -Z Plane */
        curVoxel.z = checked.z - radius;
        if (curVoxel.z > 0) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.y = max(0, checked.y - radius + 1); (curVoxel.y < (checked.y + radius - 1)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
    }
    return max_search_radius; // Shouldn't happen unless entire map is empty or max search dist reached
}

/*
int findClosestVoxelSafe(ivec3 checked) {
    for (int radius = 1; radius < max_search_radius; radius++) {
        for (int x = -radius; x <= radius; x++) {
            for (int y = -radius; y <= radius; y++) {
                for (int z = -radius; z <= radius; z++) {
                    if (x == radius || x == -radius || y == radius || y == -radius || z == radius || z == -radius) {
                        ivec3 curPos = ivec3(checked.x + x, checked.y + y, checked.z + z);
                        if (curPos.x >= 0 && curPos.x < CHUNK_WIDTH_VOXELS &&
                            curPos.y >= 0 && curPos.y < CHUNK_WIDTH_VOXELS &&
                            curPos.z >= 0 && curPos.z < CHUNK_HEIGHT_VOXELS) {
                            int voxelAtPosition = getVoxel(curPos);
                            if (voxelAtPosition < 0)
                                return radius - 1;
                        }
                    }
                }
            }
        }
    }
    return max_search_radius - 1;
}
*/

layout(local_size_x = 8, local_size_y = 8, local_size_z = 4) in;

void main() {
    //return;
    if (getVoxel(ivec3(gl_GlobalInvocationID)) == 0) {
        setVoxel(ivec3(gl_GlobalInvocationID), findClosestVoxel(ivec3(gl_GlobalInvocationID)));
    }
}
