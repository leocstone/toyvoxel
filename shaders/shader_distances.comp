#version 450
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

const int CHUNK_WIDTH_METERS = 16;
const int CHUNK_HEIGHT_METERS = 32;
const int VOXELS_PER_METER = 16;
const int CHUNK_WIDTH_VOXELS = CHUNK_WIDTH_METERS * VOXELS_PER_METER;
const int CHUNK_HEIGHT_VOXELS = CHUNK_HEIGHT_METERS * VOXELS_PER_METER;

/*
struct VoxelChunk {
    int voxels[CHUNK_WIDTH_VOXELS * CHUNK_WIDTH_VOXELS * CHUNK_HEIGHT_VOXELS];
};
*/

/*
layout(push_constant) uniform PushConstants {
    ivec3 voxelOffset;
} pushConstants;
*/

layout(std430, binding = 0, row_major) buffer VoxelChunkIn {
    int8_t voxels[CHUNK_WIDTH_VOXELS][CHUNK_WIDTH_VOXELS][CHUNK_HEIGHT_VOXELS];
};

int flatIndex(ivec3 coord) {
    return coord.x + coord.y * CHUNK_WIDTH_VOXELS + coord.z * CHUNK_WIDTH_VOXELS * CHUNK_WIDTH_VOXELS;
}

int8_t getVoxel(ivec3 coord) {

    if ((coord.x < 0) ||
        (coord.x >= CHUNK_WIDTH_VOXELS) ||
        (coord.y < 0) ||
        (coord.y >= CHUNK_WIDTH_VOXELS) ||
        (coord.z < 0) ||
        (coord.z >= CHUNK_HEIGHT_VOXELS)) {
        return int8_t(0);
    }

    //return int8_t(0);
    return voxels[coord.x][coord.y][coord.z];
}

void setVoxel(ivec3 coord, int v) {

    if ((coord.x < 0) ||
        (coord.x >= CHUNK_WIDTH_VOXELS) ||
        (coord.y < 0) ||
        (coord.y >= CHUNK_WIDTH_VOXELS) ||
        (coord.z < 0) ||
        (coord.z >= CHUNK_HEIGHT_VOXELS)) {
        return;
    }

    voxels[coord.x][coord.y][coord.z] = int8_t(v);
}

const int max_search_radius = 64;
int findClosestVoxel(ivec3 checked) {
    /*
    if (checked.x < 0 || checked.y < 0 || checked.z < 0 ||
        checked.x >= CHUNK_WIDTH_VOXELS || checked.y >= CHUNK_WIDTH_VOXELS || checked.z >= CHUNK_HEIGHT_VOXELS)
        return 0;
    */
    for (int radius = 1; radius <= max_search_radius; radius++) {
        /* Currently checked voxel */
        ivec3 curVoxel = checked;
        //int minDistanceFound = max_search_radius; // Minimum distance value found in a voxel at this radius
        /* +X Plane */
        curVoxel.x = checked.x + radius;
        if (curVoxel.x < CHUNK_WIDTH_VOXELS) {
            for (curVoxel.y = max(0, checked.y - radius); (curVoxel.y <= (checked.y + radius)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z <= (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* -X Plane */
        curVoxel.x = checked.x - radius;
        if (curVoxel.x > 0) {
            for (curVoxel.y = max(0, checked.y - radius); (curVoxel.y <= (checked.y + radius)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z <= (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* +Y Plane */
        curVoxel.y = checked.y + radius;
        if (curVoxel.y < CHUNK_WIDTH_VOXELS) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z < (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* -Y Plane */
        curVoxel.y = checked.y - radius;
        if (curVoxel.y > 0) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.z = max(0, checked.z - radius); (curVoxel.z < (checked.z + radius)) && (curVoxel.z < CHUNK_HEIGHT_VOXELS); curVoxel.z++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* +Z Plane */
        curVoxel.z = checked.z + radius;
        if (curVoxel.z < CHUNK_HEIGHT_VOXELS) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.y = max(0, checked.y - radius + 1); (curVoxel.y < (checked.y + radius - 1)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
        /* -Z Plane */
        curVoxel.z = checked.z - radius;
        if (curVoxel.z > 0) {
            for (curVoxel.x = max(0, checked.x - radius + 1); (curVoxel.x < (checked.x + radius - 1)) && (curVoxel.x < CHUNK_WIDTH_VOXELS); curVoxel.x++) {
                for (curVoxel.y = max(0, checked.y - radius + 1); (curVoxel.y < (checked.y + radius - 1)) && (curVoxel.y < CHUNK_WIDTH_VOXELS); curVoxel.y++) {
                    if (getVoxel(curVoxel) < 0)
                        return radius - 1;
                }
            }
        }
    }
    return 0;//max_search_radius; // Shouldn't happen unless entire map is empty or max search dist reached
}

int findClosestVoxelSafe(ivec3 checked) {
    for (int radius = 1; radius < max_search_radius; radius++) {
        for (int x = checked.x - radius; x < checked.x + radius + 1; x++) {
            if (x < 0 || x >= CHUNK_WIDTH_VOXELS)
                continue;
            for (int y = checked.y - radius; y < checked.y + radius + 1; y++) {
                if (y < 0 || y >= CHUNK_WIDTH_VOXELS)
                    continue;
                for (int z = checked.z - radius; z < checked.z + radius + 1; z++) {
                    if (z < 0 || z >= CHUNK_WIDTH_VOXELS)
                        continue;
                    //boundsCheck(x, y, z);
                    if (getVoxel(ivec3(x, y, z)) < 0) {
                        return radius - 1;
                    }
                }
            }
        }
    }
    return 0;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 16) in;

void main() {
    ivec3 curIndex = ivec3(gl_GlobalInvocationID);// + pushConstants.voxelOffset;
    if (getVoxel(curIndex) == 0) {
        setVoxel(curIndex, int8_t(findClosestVoxelSafe(curIndex)));
    }
}
