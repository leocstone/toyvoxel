#version 450

const int CHUNK_SIZE = 16;
const int CHUNK_HEIGHT = 384;
/*
struct VoxelChunk {
    uint voxels[CHUNK_WIDTH][CHUNK_WIDTH][CHUNK_HEIGHT];
};
*/
/*
layout(binding = 0) uniform Camera {
    vec3 position;
    vec3 forward;
    // Up is constant?
} camera;
*/

layout(binding = 0, rgba8) uniform writeonly image2D outputImage;
/*
layout(std140, binding = 1) readonly buffer VoxelChunkIn {
    VoxelChunk chunkIn;
};

layout(std140, binding = 2) buffer VoxelChunkOut {
    VoxelChunk chunkOut;
};
*/
const double VOXEL_SIZE = 1.0;

const int MAX_STEPS = 32;

// x: distance
// y: hit a voxel if >0 (could be id later)
float distanceToVoxel(vec3 origin, vec3 endpoint) {
    vec3 direction = normalize(endpoint - origin);
    
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 currentPos = origin + direction * i;
        ivec3 currentVoxel = ivec3(currentPos);
        // Skip out of bounds indices
        if (currentVoxel.x < 0 || currentVoxel.x > CHUNK_SIZE)
            continue;
        if (currentVoxel.y < 0 || currentVoxel.y > CHUNK_SIZE)
            continue;
        if (currentVoxel.z < 0 || currentVoxel.z > CHUNK_HEIGHT)
            continue;
        if (int(currentVoxel.x + currentVoxel.y + currentVoxel.z) % 2 == 0) {
            // This is definitely wrong - should be intersection with plane on voxel grid
            return 1.0 - float(i) / float(MAX_STEPS);
        }
    }
    
    return 0.0;
}

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void main() {
    /* Avoid OOB operations */
    ivec2 sz = imageSize(outputImage);
    if (gl_GlobalInvocationID.x > sz.x || gl_GlobalInvocationID.y > sz.y) {
        return;
    }

    const vec2 pixel = vec2(gl_GlobalInvocationID.xy);
    const vec2 pixelDimensions = vec2(sz);
    
    const vec3 cameraPos = vec3(-CHUNK_SIZE, 0, CHUNK_SIZE * 2);
    const vec3 cameraForward = normalize(vec3(1, 0, 0));
    const vec3 cameraUp = vec3(0, 0, 1);
    const vec3 cameraRight = cross(cameraForward, cameraUp);
    
    const float focalLength = 2.0;
    const float lensX = 3.0;
    const float lensY = (pixelDimensions.y / pixelDimensions.x) * lensX;
    
    const vec3 rayOrigin = cameraPos;
    vec3 rayDirection = cameraPos + cameraForward * focalLength + cameraForward;
    // Cast ray through "lens" at corresponding pixel point
    rayDirection -= cameraUp * (lensY / 2.0);
    rayDirection -= cameraRight * (lensX / 2.0);
    rayDirection += (pixel.x / pixelDimensions.x) * cameraRight;
    rayDirection += (pixel.y / pixelDimensions.y) * cameraUp;
    
    vec3 outputColor = vec3(distanceToVoxel(rayOrigin, rayDirection));
    
    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(outputColor.xyz, 1.0));
    
    //imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixel.x / pixelDimensions.x, pixel.y / pixelDimensions.y, 0.0, 1.0));
}
