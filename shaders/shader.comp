#version 450

const int CHUNK_SIZE = 16;
const int CHUNK_HEIGHT = 384;
/*
struct VoxelChunk {
    uint voxels[CHUNK_WIDTH][CHUNK_WIDTH][CHUNK_HEIGHT];
};
*/

layout(binding = 0) uniform Camera {
    vec3 position;
    vec3 forward;
    vec3 up;
    vec3 right;
} camera;

layout(binding = 1, rgba8) uniform writeonly image2D outputImage;
/*
layout(std140, binding = 1) readonly buffer VoxelChunkIn {
    VoxelChunk chunkIn;
};

layout(std140, binding = 2) buffer VoxelChunkOut {
    VoxelChunk chunkOut;
};
*/
const float VOXEL_SIZE = 1.0;

const int MAX_STEPS = 64;

float distanceToVoxel(vec3 origin, vec3 endpoint) {
    vec3 direction = normalize(endpoint - origin);
    
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 currentPos = origin + direction * i;
        ivec3 currentVoxel = ivec3(currentPos);
        // Skip out of bounds indices
        if (currentVoxel.x < 0 || currentVoxel.x > CHUNK_SIZE)
            continue;
        if (currentVoxel.y < 0 || currentVoxel.y > CHUNK_SIZE)
            continue;
        if (currentVoxel.z < 0 || currentVoxel.z > CHUNK_HEIGHT)
            continue;
        if (int(currentVoxel.x + currentVoxel.y + currentVoxel.z) % 2 == 0) {
            // This is definitely wrong - should be intersection with plane on voxel grid
            return 1.0 - float(i) / float(MAX_STEPS);
        }
    }
    
    return 0.0;
}

float lightIntensity(vec3 eye, vec3 point) {
    const vec3 lightPos = vec3(-3, 3, 3);
    const vec3 directionToEye = normalize(eye - point);
    const vec3 directionToLight = normalize(lightPos - point);
    const vec3 surfaceNormal = normalize(point); /* Unit sphere... */
    return dot(directionToEye, directionToLight);
}

vec4 distanceToSphereAlongRay(vec3 origin, vec3 endpoint) {
    vec3 direction = normalize(endpoint - origin);
    
    float curDistanceToSphere = length(origin) - 1.0;
    vec3 checkedPoint = origin + direction * curDistanceToSphere;

    if (length(checkedPoint) <= 1.01) {
        return vec4(checkedPoint.xyz, curDistanceToSphere);
    }
    return vec4(-1);
}

vec3 skyboxColorInDirection(vec3 direction) {
    return cos(direction.z) * vec3(0.2, 0.2, 0.8) + (direction.z + 1) * vec3(0.2, 0.2, 0.8) * 0.1;
}

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void main() {
    /* Avoid OOB operations */
    ivec2 sz = imageSize(outputImage);
    if (gl_GlobalInvocationID.x > sz.x || gl_GlobalInvocationID.y > sz.y) {
        return;
    }

    const vec2 pixel = vec2(gl_GlobalInvocationID.xy);
    const vec2 pixelDimensions = vec2(sz);
    
    /*
    const vec3 cameraPos = vec3(-2, 0, 0);
    const vec3 cameraForward = normalize(vec3(1, 0, 0));
    const vec3 cameraUp = vec3(0, 0, 1);
    const vec3 cameraRight = cross(cameraForward, cameraUp);
    */
    
    const float focalLength = 1.0;
    const float lensX = 1.0;
    const float lensY = (pixelDimensions.y / pixelDimensions.x) * lensX;
    
    const vec3 rayOrigin = camera.position;
    vec3 rayDirection = camera.position + camera.forward * focalLength;
    // Cast ray through "lens" at corresponding pixel point
    rayDirection += camera.up * (lensY / 2.0);
    rayDirection -= camera.right * (lensX / 2.0);
    rayDirection += (pixel.x / pixelDimensions.x) * camera.right * lensX;
    rayDirection -= (pixel.y / pixelDimensions.y) * camera.up * lensY;
    
    //vec4 rayCast = distanceToSphereAlongRay(rayOrigin, rayDirection);
    //vec3 outputColor = rayCast.w > 0 ? vec3(1.0) * lightIntensity(rayOrigin, rayCast.xyz) : skyboxColorInDirection(normalize(rayDirection - rayOrigin)); 
    vec3 outputColor = vec3(distanceToVoxel(rayOrigin, rayDirection));
    
    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(outputColor, 1.0));
    //imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(outputColor.xyz, 1.0));
    
    //imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixel.x / pixelDimensions.x, pixel.y / pixelDimensions.y, 0.0, 1.0));
}
