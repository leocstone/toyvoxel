#version 450

const int CHUNK_WIDTH = 16;
const int CHUNK_HEIGHT = 384;
/*
struct VoxelChunk {
    uint voxels[CHUNK_WIDTH][CHUNK_WIDTH][CHUNK_HEIGHT];
};
*/
/*
layout(binding = 0) uniform Camera {
    vec3 position;
    vec3 forward;
    // Up is constant?
} camera;
*/

layout(binding = 0, rgba8) uniform writeonly image2D outputImage;
/*
layout(std140, binding = 1) readonly buffer VoxelChunkIn {
    VoxelChunk chunkIn;
};

layout(std140, binding = 2) buffer VoxelChunkOut {
    VoxelChunk chunkOut;
};

const double VOXEL_SIZE = 1.0;

const MAX_STEPS = 32;

// x: distance
// y: hit a voxel if >0 (could be id later)
vec2 distanceToVoxel(vec3 origin, vec3 endpoint) {
    vec3 direction = normalize(endpoint - origin);
    
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 currentPos = origin + direction * i;
        ivec3 currentVoxel = ivec3(currentPos);
        // Skip out of bounds indices
        if (currentVoxel.x < 0 || currentVoxel.x > CHUNK_SIZE)
            continue;
        if (currentVoxel.y < 0 || currentVoxel.y > CHUNK_SIZE)
            continue;
        if (currentVoxel.z < 0 || currentVoxel.z > CHUNK_HEIGHT)
            continue;
        if (chunkIn.voxels[currentVoxel.x][currentVoxel.y][currentVoxel.z]) {
            // This is definitely wrong - should be intersection with plane on voxel grid
            return vec2(length(direction * i), 1);
        }
    }
    
    return vec2(0, -1);
}
*/
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
    const vec2 pixel = vec2(gl_GlobalInvocationID.xy);
    const vec2 pixelDimensions = vec2(imageSize(outputImage));
    /*
    const vec3 cameraPos = vec3(-CHUNK_SIZE * 2, -CHUNK_SIZE * 2, CHUNK_SIZE * 2);
    const vec3 cameraForward = normalize(vec3(1, 0, 0));
    const vec3 cameraUp = vec3(0, 0, 1);
    const vec3 cameraRight = cross(cameraForward, cameraUp);
     
    
    const float focalLength = 2.0;
    const float lensX = 3.0;
    const float lensY = (pixelDimensions.y / pixelDimensions.x) * lensX;
    
    const vec3 rayOrigin = cameraPos;
    const vec3 rayDirection = cameraPos + cameraForward * focalLength + cameraForward;
    // Cast ray through "lens" at corresponding pixel point
    rayDirection -= cameraUp * (lensY / 2.0);
    rayDirection -= cameraRight * (lensX / 2.0);
    rayDirection += (pixel.x / pixelDimensions.x) * cameraRight;
    rayDirection += (pixel.y / pixelDimensions.y) * cameraUp;
    
    const vec2 raycastResult = distanceToVoxel(rayOrigin, rayDirection);
    
    const vec3 outputColor = raycastResult.y > 0 ? vec3(1.0 - raycastResult.x / float(MAX_STEPS)) : vec3(0.0);
    
    //imageStore(outputImage, pixel, vec4(outputColor.xyz, 1.0);
    */
    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixel.x / pixelDimensions.x, pixel.y / pixelDimensions.y, 0.0, 1.0));
}
