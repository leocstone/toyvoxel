#version 450

const int CHUNK_SIZE = 16;
const int CHUNK_HEIGHT = 384;
/*
struct VoxelChunk {
    uint voxels[CHUNK_WIDTH][CHUNK_WIDTH][CHUNK_HEIGHT];
};
*/

layout(binding = 0) uniform Camera {
    vec3 position;
    vec3 forward;
    vec3 up;
    vec3 right;
} camera;

layout(binding = 1, rgba8) uniform writeonly image2D outputImage;
/*
layout(std140, binding = 1) readonly buffer VoxelChunkIn {
    VoxelChunk chunkIn;
};

layout(std140, binding = 2) buffer VoxelChunkOut {
    VoxelChunk chunkOut;
};
*/

const int MAX_STEPS = 64;
const float MAX_DIST = 100.0;
vec3 sunDir = normalize(vec3(1, -1, -1));

/*
Copied from iq
*/
float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sdBoxFrame( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;
  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

float sdPlane( vec3 p, vec3 n, float h )
{
  // n must be normalized
  return dot(p,n) + h;
}

float distanceToSphere(vec3 point, vec3 sphereOrigin, float radius) {
    return length(point - sphereOrigin) - radius;
}

float distanceToWorld(vec3 point) {
    return min(point.z, distanceToSphere(point, vec3(0.0, 0.0, 3.0), 1.0));
}

/*
Returns vec4:
xyz: point of intersection
w:   distance, or -1 if no intersection
*/
vec4 distanceToWorldAlongRay(vec3 origin, vec3 endpoint, float maxlen) {
    vec3 direction = normalize(endpoint - origin);
    
    float distTraveled = 0.0;
    for (int i = 0; i < MAX_STEPS && distTraveled < maxlen; i++) {
        float curDist = distanceToWorld(origin + direction * distTraveled);
        if (curDist <= 0.000001) {
            return vec4(origin + direction * distTraveled, distTraveled);
        }
        distTraveled += curDist;
    }
    
    return vec4(-1.0);
}

/*
Returns 1.0 if there is a world intersection along given ray, or -1.0 otherwise
*/
float intersectionAlongRay(vec3 origin, vec3 endpoint, float maxlen) {
    return distanceToWorldAlongRay(origin, endpoint, maxlen).w >= 0.0 ? 1.0 : -1.0;
}

/*
Copied from iq's Menger Sponge example on shadertoy
*/
vec3 calcNormal(vec3 pos)
{
    vec3 eps = vec3(.001,0.0,0.0);
    return normalize(vec3(
            distanceToWorld(pos+eps.xyy).x - distanceToWorld(pos-eps.xyy).x,
            distanceToWorld(pos+eps.yxy).x - distanceToWorld(pos-eps.yxy).x,
            distanceToWorld(pos+eps.yyx).x - distanceToWorld(pos-eps.yyx).x ));
}

const float shadowOffset = 0.01;
/*
Computes the intensity of lighting coming directly from the sun at a given point
*/
float directLightingAtPoint(vec3 point) {
    vec3 normal = calcNormal(point);
    point += normal * shadowOffset;
    if (intersectionAlongRay(point, -sunDir, MAX_DIST) >= 1.0) {
        return 0.0;
    }
    return 1.0 * clamp(dot(-sunDir, normal), 0.0, 1.0);
}

vec3 skyboxColorInDirection(vec3 direction) {
    return vec3(0.42, 0.69, 0.92);
}

/* Copied from stackoverflow - random number in [0.0, 1.0] */
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

/*
1 if there is a voxel, 0 otherwise
*/
bool voxelVolume(ivec3 voxel) {
    if (voxel.x < 0 || voxel.y < 0 || voxel.z < 0 || voxel.z > 50)
        return false;
    return (voxel.x + voxel.y + voxel.z) % 2 == 0;
}

const float eps = 0.999;

/*
xyz: normal at intersection
w:   distance to intersection
*/
vec4 distanceToVoxelAlongRay(vec3 origin, vec3 endpoint, float maxlen) {
    const vec3 direction = normalize(endpoint - origin);
    const vec3 rayAxesDirections = sign(direction);
    vec3 curPos = origin;
    float totalDist = 0.0;
    int i = 0;
    for (; i < MAX_STEPS && totalDist < maxlen; i++) {
        // For each axis, coordinate of the next plane we will reach
        // (try trunc(curPos + sign * 0.99), or round(curPos + sign * 0.5))
        vec3 nextPlaneCoords = floor(curPos + (vec3(1) + rayAxesDirections) * 0.999999999);
        nextPlaneCoords.x = rayAxesDirections.x >= 0.0 ? floor(curPos.x + 0.999999999) : ceil(curPos.x - 0.999999999);
        nextPlaneCoords.y = rayAxesDirections.y >= 0.0 ? floor(curPos.y + 0.999999999) : ceil(curPos.y - 0.999999999);
        nextPlaneCoords.z = rayAxesDirections.z >= 0.0 ? floor(curPos.z + 0.999999999) : ceil(curPos.z - 0.999999999);
        // For each axis, the distance along direction to the next plane we will reach
        // (any zeros in direction are handled here - they should become INF)
        vec3 nextPlaneDistances = abs((nextPlaneCoords - curPos) / direction);
        // Find the minimum of these, so we just travel far enough to get to the next plane intersection (we don't want to skip any voxels!)
        float minPlaneDistance = min(nextPlaneDistances.x, 
                                     min(nextPlaneDistances.y, nextPlaneDistances.z));
        // Travel that minimum distance to the next plane
        float distanceTraveled = minPlaneDistance;
        totalDist += distanceTraveled;
        curPos += distanceTraveled * direction;
        ivec3 curVoxel = ivec3(0, 0, 0);
        vec3 normal = vec3(0, 0, 0);
        if (nextPlaneDistances.x == minPlaneDistance) {
            // Set current voxel
            curVoxel.x = int(direction.x < 0.0 ? floor(curPos.x - eps) : round(curPos.x));
            curVoxel.y = int(floor(curPos.y));
            curVoxel.z = int(floor(curPos.z));
            // Set normal
            normal.x = -rayAxesDirections.x;
        } else if (nextPlaneDistances.y == minPlaneDistance) {
            // Set current voxel
            curVoxel.x = int(floor(curPos.x));
            curVoxel.y = int(direction.y < 0.0 ? floor(curPos.y - eps) : round(curPos.y));
            curVoxel.z = int(floor(curPos.z));
            // Set normal
            normal.y = -rayAxesDirections.y;
        } else {
            // Set current voxel
            curVoxel.x = int(floor(curPos.x));
            curVoxel.y = int(floor(curPos.y));
            curVoxel.z = int(direction.z < 0.0 ? floor(curPos.z - eps) : round(curPos.z));
            // Set normal
            normal.z = -rayAxesDirections.z;
        }
        // We should now be intersecting a plane - is there a voxel face at that intersection?
        if (voxelVolume(curVoxel)) {
            return vec4(vec3(curVoxel) / 16.0, totalDist);
        }
    }
    return vec4(vec3(0.0), -1.0);
}

const int SAMPLES = 1;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void main() {
    /* Avoid OOB operations */
    ivec2 sz = imageSize(outputImage);
    if (gl_GlobalInvocationID.x > sz.x || gl_GlobalInvocationID.y > sz.y) {
        return;
    }

    const vec2 pixel = vec2(gl_GlobalInvocationID.xy);
    const vec2 pixelDimensions = vec2(sz);
    
    const float focalLength = 1.0;
    const float lensX = 1.0;
    const float lensY = (pixelDimensions.y / pixelDimensions.x) * lensX;
    const float pixelSize = lensX / pixelDimensions.x;
    
    const vec3 rayOrigin = camera.position;
    vec3 rayDirection = camera.position + camera.forward * focalLength;
    // Cast ray through "lens" at corresponding pixel point
    rayDirection += camera.up * (lensY / 2.0);
    rayDirection -= camera.right * (lensX / 2.0);
    rayDirection += (pixel.x / pixelDimensions.x) * camera.right * lensX;
    rayDirection -= (pixel.y / pixelDimensions.y) * camera.up * lensY;
    
    vec3 outputColor = vec3(0.0);
    for (int i = 0; i < SAMPLES; i++) {
        vec3 randomOffset = camera.right * random(vec2(pixel.x + i, pixel.y)) - camera.up * random(vec2(pixel.x, pixel.y + i));
        vec3 curSampleDirection = rayDirection + randomOffset * pixelSize;
        vec4 curSample = distanceToVoxelAlongRay(rayOrigin, curSampleDirection, MAX_DIST);
        outputColor += curSample.w > 0.0 ? curSample.xyz * 0.55 : vec3(1.0);
    }
    outputColor /= float(SAMPLES);
    outputColor = vec3(pow(outputColor.x, 0.45), pow(outputColor.y, 0.45), pow(outputColor.z, 0.45));
    
    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(outputColor.xyz, 1.0));
}
